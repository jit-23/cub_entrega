void draw_line(t_cub *cub, float angl_start, int i)
{
 // **Player Position**
 int mapX = (int)cub->px;  
 int mapY = (int)cub->py;  

double fov = PI/3;
double planeLength = tan(fov / 2);

double dirX = cos(cub->angle);
double dirY = sin(cub->angle);
//double planeX = 0, planeY = 0.66; //the 2d raycaster version of camera plane
double planeX = -dirY * planeLength;
double planeY =  dirX * planeLength;

double cameraX = 2 * i / (double)WIDTH - 1;

double rayDirX = dirX + planeX * cameraX;
double rayDirY = dirY + planeY * cameraX;
double deltaDistX = sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX));
double deltaDistY = sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY));

/// **Calculate Initial Side Distances**
double sideDistX, sideDistY; // valores que x e y tem que percorrer para o RAIO dar o valor certo e bater 
// no vertice do tile seguinte 
int stepX, stepY; // valor positivo ou negativo para diferenciar o lado certo a percorrer

if (rayDirX < 0) { //esquerda
	stepX = -1; // valor para 
	sideDistX = (cub->px - mapX) * deltaDistX;
 } else {
	 stepX = 1;
	 sideDistX = (mapX + 1.0 - cub->px) * deltaDistX;
}

if (rayDirY < 0)
	{
		stepY = -1; // baixo
		sideDistY = (cub->py - mapY) * deltaDistY;
	} 
else {
	stepY = 1; // cima
	sideDistY = (mapY + 1.0 - cub->py) * deltaDistY;
 }
 
 // **DDA Raycasting Loop**

 int hit = 0;
 int side; // 0 = X wall, 1 = Y wall
 while (hit == 0) {
	 // Move in the direction of the shortest step
	if (sideDistX < sideDistY) {
		 sideDistX += deltaDistX;
		 mapX += stepX;
		 side = 0;
	} else {
		 sideDistY += deltaDistY;
		 mapY += stepY;
		 side = 1;
	}
	 // Check for a collision (wall hit)
	 if (colision(mapX, mapY, cub)) {
		 hit = 1;
	}
}

// **Calculate Distance to Wall**
  double perpWallDist;
	if (side == 0)
   		perpWallDist = (mapX - cub->px + (1 - stepX) / 2) / rayDirX;
	else
    	perpWallDist = (mapY - cub->py + (1 - stepY) / 2) / rayDirY;
double lineHeight = (BLOCK * HEIGH ) / perpWallDist ;
 int drawStart = -lineHeight / 2 + HEIGH / 2;
 if (drawStart < 0) 
	drawStart = 0;

int drawEnd = lineHeight / 2 + HEIGH / 2;

if (drawEnd >= HEIGH)
	drawEnd = HEIGH - 1;

double xwall;// = mapY + perpWallDist * rayDirY;

if (side == 0)
    xwall = cub->py + perpWallDist * rayDirY;
else
    xwall = cub->px + perpWallDist * rayDirX;
xwall = fmod(xwall, BLOCK)/BLOCK ;
int texX =  (int) ((xwall) * ((double)cub->imgs[0].x));
if ((side == 0 && rayDirX < 0))
    texX = cub->imgs[0].x - texX - 1;
if (side == 1 && rayDirY > 0)
    texX = cub->imgs[0].x - texX - 1;
int y = drawStart;
float step = 1.0 * cub->imgs[0].y /lineHeight ;//BLOCK;
float texPos = (drawStart - HEIGH / 2 + lineHeight / 2) * step;

for (int y = 0; y < drawStart; y++)
	my_mlx_pixel_put(&cub->imgs[1], i, y, 0xFF);

// Draw Floor
for (int y = drawEnd; y < HEIGH; y++)
	my_mlx_pixel_put(&cub->imgs[1], i, y, 0xFFFF);

while (y < drawEnd) {
	int texY = (int)texPos;
	if (texY < 0)
        texY = 0;
	if (texY >= cub->imgs[0].y) 
        texY = cub->imgs[0].y - 1;

	int color = *(int *)(cub->imgs[0].addr +
                (texY * cub->imgs[0].size_line + texX * (cub->imgs[0].bpp / 8)));
	my_mlx_pixel_put(&cub->imgs[1], i, y, color);
	texPos += step;
	y++;
}
}